/*
This source file is part of KBEngine
For the latest info, see http://www.kbengine.org/

Copyright (c) 2008-2012 kbegine Software Ltd
Also see acknowledgements in Readme.html

You may use this sample code for anything you like, it is not covered by the
same license as the rest of the engine.
*/
/*
	IDAllocate(分配器)
		用来分配一个本分配器所管理的唯一id。 使用这个分配器必须自己保证， 一个应用只能使用
		同一个id分配器来获取id才是唯一的。
		
		如果是一个 unsigned int类型， 这个分配器会一直向上分配， 当达到类型的最大值之后会
		从转头又从0开始向上累加分配， 它会从list中寻找， 如果当前要分配的ID没有在list中找到
		那么这个id将被分配。

		用法:
		IDAllocate<ENTITY_ID>* m_IDAllocPtr = new IDAllocate<ENTITY_ID>;
		// 分配一个id 
		m_IDAllocPtr->alloc()
		// 回收一个id
		m_IDAllocPtr->reclaim()
		
	IDServer(服务器)
		这个主要是提供整个服务器组之间的entityID的分配， 他主要被baseappmgr使用， 每个IDserver
		请求获取ID的时候， 这个服务器就会分配一个唯一id段给客户端， 那么客户端就可以根据这个段
		产生所有的唯一id并进行自由的分派。
		
		用法:
		IDServer<ENTITY_ID>* m_idServer = new IDServer<ENTITY_ID>(1, 400);
		// 获取一个id段 并传输给IDClient
		std::pair< unsigned int, unsigned int > idRange = m_idServer->allocRange();
		g_socketStreamIDClient->send(idRange.first, idRange.second);
		
	IDClient(客户端)
		这个模块是配合IDServer进行id申请和接收的， 。
		
		用法:
		IDClient<ENTITY_ID>* m_idClient = new IDClient<ENTITY_ID>;
		// 添加IDServer发送过来的id段
		m_idClient->onAddRange(idBegin, idEnd);
		// 分配一个id 
		m_idClient->alloc()
*/
#ifndef __IDAllocate_H__
#define __IDAllocate_H__

// common include	
#include "helper/debug_helper.hpp"
#include "cstdkbe/cstdkbe.hpp"
//#define NDEBUG
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <iostream>	
#include <queue>	
// windows include	
#if KBE_PLATFORM == PLATFORM_WIN32
#else
// linux include
#include <errno.h>
#endif
	
namespace KBEngine{

template< typename T >
class IDAllocate
{
protected:
	typename std::queue< T > idList_;						// id列表， 所有ID都存在这个列表里
	T lastID_;											// 最后一次申请到的ID
public:
	IDAllocate(): lastID_(0)
	{
	}

	~IDAllocate()
	{
	}	
	
	/** 分配一个id */
	T alloc(void)
	{
		if(idList_.size() > 0)
		{
			T n = idList_.front();
			idList_.pop();
			return n;
		}
		
		return ++lastID_;
	}
	
	/** 回收一个id */
	void reclaim(T id)
	{
		idList_.push(id);
	}
	
};


template< typename T >
class IDServer
{
protected:
	T lastIDRange_begin_;										// 最后一次申请到的ID段的起始位置
	T rangeStep_;												// id段的一个段长度
public:
	IDServer(T idBegin, T rangeStep): 
	lastIDRange_begin_(idBegin), 
	rangeStep_(rangeStep)
	{
	}

	~IDServer()
	{
	}	
	
	/** 分配一个id段 */
	std::pair< T, T > allocRange(void)
	{
		DEBUG_MSG("IDServer::allocRange: %d-%d.\n", lastIDRange_begin_, lastIDRange_begin_ + rangeStep_);
		std::pair< T, T > p = std::make_pair(lastIDRange_begin_, lastIDRange_begin_ + rangeStep_);
		lastIDRange_begin_ += rangeStep_;
		return p;
	}
};

template< typename T >
class IDClient
{										
public:
	IDClient():lastIDRange_begin_(0), lastIDRange_end_(0)
	{
	}
	
	/** 析构时不会通知IDServer进行回收， 请使用者自己进行这方面的维护 */
	~IDClient()
	{
	}	
	
	size_t getSize()const{ return lastIDRange_end_ - lastIDRange_begin_; }
	
	/** idserver 分配过来的一个id段 */
	void onAddRange(T idBegin, T idEnd)
	{
		DEBUG_MSG("IDClient::onAddRange: number of ids increased from %d to %d.\n", idBegin, idEnd);
		if(getSize() <= 0)
		{
			lastIDRange_begin_ = idBegin;
			lastIDRange_end_ = idEnd;
		}
		else
		{
			idList_.push(std::make_pair(idBegin, idEnd));
		}
	}
	
	/** 分配一个id */
	T alloc(void)
	{
		assert(getSize() > 0 && "IDClient:: alloc:no usable of the id.\n");
		T id = lastIDRange_begin_;
		lastIDRange_begin_ ++;
		if(lastIDRange_begin_ > lastIDRange_end_)
		{
			if(idList_.size() > 0)
			{
				std::pair< T, T > n = idList_.front();
				lastIDRange_begin_ = n.first;
				lastIDRange_end_ = n.second;
				idList_.pop();
			}
			else
			{
				lastIDRange_begin_ = lastIDRange_end_ = 0;
			}
		}
		return id;
	}
	
	/** 回收一个id */
	void onReclaim(T id)
	{
	}
	
protected:
	typename std::queue< std::pair< T, T > > idList_;					// id列表， 所有ID都存在这个列表里
	T lastIDRange_begin_;												// 最后一次申请到的ID段的起始位置
	T lastIDRange_end_;		
};


}
#endif
